{"version":3,"file":"rules.min.js","sources":["../../src/form/rules.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This file contains a set of rules that elements can be compared against to determine if they should be shown, hidden, etc...\n *\n * @See /lib/pear/HTML/QuickForm/Rule/Compare.php\n * @See https://pear.php.net/manual/en/package.html.html-quickform2.rules.list.php for a list of available rules.\n *\n * @module     core_form/form/rules\n * @copyright  2024 Mathew May <mathew.solutions>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\"use strict\";\n\nimport {determineDisplayMap, mapTemplate} from './display';\n\nexport default class Rules {\n    /**\n     * @var {Form} formInstance The instance of the form class that has a DOM node & references matched.\n     */\n    formInstance;\n\n    /**\n     * Boilerplate for the common variables.\n     * @returns {{displayMap: Map<String, Array>, lock: boolean}}\n     */\n    common() {\n        const displayMap = mapTemplate();\n        let lock = false;\n        return {displayMap, lock};\n    }\n\n    /**\n     * Compare the value of the checkbox vs if it is not checked.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to be compared against the requested rule.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    notchecked(target) {\n        let {displayMap, lock} = this.common();\n        this.formInstance.getDependantsOfType(target.name, 'notchecked').forEach((dependant, key) => {\n            if (target.type !== 'hidden') {\n                lock = Boolean(key) !== target.checked;\n                determineDisplayMap(dependant, displayMap, lock);\n            }\n        });\n        return displayMap;\n    }\n\n    /**\n     * Compare the value of the checkbox and if it is checked.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to be compared against the requested rule.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    checked(target) {\n        let {displayMap, lock} = this.common();\n        this.formInstance.getDependantsOfType(target.name, 'checked').forEach((dependant, key) => {\n            if (target.type !== 'hidden') {\n                lock = Boolean(key) === target.checked;\n                determineDisplayMap(dependant, displayMap, lock);\n            }\n        });\n        return displayMap;\n    }\n\n    /**\n     * Compare the value of the changed DOM node equals the rule value.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to be compared against the requested rule.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    eq(target) {\n        let {displayMap, lock} = this.common();\n        this.formInstance.getDependantsOfType(target.name, 'eq').forEach((dependant, key) => {\n            if (target.type === 'radio') {\n                lock = String(key) === String(this.getRadioFieldVal(target));\n            } else if (target.type === 'hidden' && this.getHiddenCkbs(target)) {\n                // This is the hidden input that is part of an advcheckbox.\n                lock = target.checked === Boolean(key);\n            } else if (target.type === 'checkbox' && !target.checked) {\n                lock = target.checked === Boolean(key);\n            } else if (target.classList.contains('filepickerhidden')) {\n                lock = !M.form_filepicker.instances[target.id].fileadded;\n            } else {\n                lock = target.value === key;\n            }\n            determineDisplayMap(dependant, displayMap, lock);\n        });\n        return displayMap;\n    }\n\n    /**\n     * Compare the value of the changed DOM node to the requested rule value.\n     * @See Moodle has some interesting aliasing ne && noteq, this is also the old \"default\" rule.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to be compared against the requested rule.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    neq(target) {\n        let {displayMap, lock} = this.common();\n        // Get all the aliases of neq and check them all at once.\n        const maps = new Map([\n            ...this.formInstance.getDependantsOfType(target.name, 'neq')?.entries() ?? [],\n            ...this.formInstance.getDependantsOfType(target.name, 'ne')?.entries() ?? [],\n            ...this.formInstance.getDependantsOfType(target.name, 'noteq')?.entries() ?? [],\n        ]);\n        maps.forEach((dependant, key) => {\n            if (target.type === 'radio') {\n                lock = String(key) !== String(this.getRadioFieldVal(target));\n            } else if (target.type === 'hidden' && this.getHiddenCkbs(target)) {\n                // This is the hidden input that is part of an advcheckbox.\n                lock = target.checked !== Boolean(key);\n            } else if (target.type === 'checkbox' && !target.checked) {\n                lock = target.checked === Boolean(key);\n            } else if (target.classList.contains('filepickerhidden')) {\n                lock = !!M.form_filepicker.instances[target.id].fileadded;\n            } else {\n                lock = target.value !== key;\n            }\n            determineDisplayMap(dependant, displayMap, lock);\n        });\n        return displayMap;\n    }\n\n    /**\n     * Compare the value of the changed DOM node vs if it is in the defined values passed as a rule.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to be compared against the requested rule.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    in(target) {\n        let {displayMap, lock} = this.common();\n        this.formInstance.getDependantsOfType(target.name, 'in').forEach((dependant, key) => {\n            lock = key.split('|').includes(target.value);\n            determineDisplayMap(dependant, displayMap, lock);\n        });\n        return displayMap;\n    }\n\n    /**\n     * Radio fields are a bit different, they need to be handled differently.\n     *\n     * @param {HTMLFormElement} target The changed DOM node to find a potential radio field for.\n     * @returns {String} The value of the radio field.\n     */\n    getRadioFieldVal(target) {\n        return target.type === 'radio' ? this.formInstance.form.elements.namedItem(target.name).value : target.value;\n    }\n\n    /**\n     * A small helper to determine if the advcheckboxes are being used.\n     *\n     * @param {HTMLFormElement} target The target element to get the hidden checkboxes for.\n     * @returns {boolean} Is this a hidden checkbox?\n     */\n    getHiddenCkbs(target) {\n        return this.formInstance.form.querySelectorAll('input[type=checkbox][name=\"' + target.name + '\"]').length !== 0;\n    }\n\n    /**\n     * Constructor for the Rules class.\n     *\n     * @param {Form} form The form object that the rules are being applied to.\n     */\n    constructor(form) {\n        this.formInstance = form;\n    }\n}\n"],"names":["common","displayMap","lock","notchecked","target","this","formInstance","getDependantsOfType","name","forEach","dependant","key","type","Boolean","checked","eq","String","getRadioFieldVal","getHiddenCkbs","classList","contains","M","form_filepicker","instances","id","fileadded","value","neq","Map","_this$formInstance$ge2","entries","_this$formInstance$ge4","_this$formInstance$ge6","in","split","includes","form","elements","namedItem","querySelectorAll","length","constructor"],"mappings":"iMAwCIA,eAGW,CAACC,YAFW,0BAECC,MADT,GAUfC,WAAWC,YACHH,WAACA,WAADC,KAAaA,MAAQG,KAAKL,qBACzBM,aAAaC,oBAAoBH,OAAOI,KAAM,cAAcC,SAAQ,CAACC,UAAWC,OAC7D,WAAhBP,OAAOQ,OACPV,KAAOW,QAAQF,OAASP,OAAOU,yCACXJ,UAAWT,WAAYC,UAG5CD,WASXa,QAAQV,YACAH,WAACA,WAADC,KAAaA,MAAQG,KAAKL,qBACzBM,aAAaC,oBAAoBH,OAAOI,KAAM,WAAWC,SAAQ,CAACC,UAAWC,OAC1D,WAAhBP,OAAOQ,OACPV,KAAOW,QAAQF,OAASP,OAAOU,yCACXJ,UAAWT,WAAYC,UAG5CD,WASXc,GAAGX,YACKH,WAACA,WAADC,KAAaA,MAAQG,KAAKL,qBACzBM,aAAaC,oBAAoBH,OAAOI,KAAM,MAAMC,SAAQ,CAACC,UAAWC,OAErET,KADgB,UAAhBE,OAAOQ,KACAI,OAAOL,OAASK,OAAOX,KAAKY,iBAAiBb,SAC7B,WAAhBA,OAAOQ,MAAqBP,KAAKa,cAAcd,QAE/CA,OAAOU,UAAYD,QAAQF,KACX,aAAhBP,OAAOQ,MAAwBR,OAAOU,QAEtCV,OAAOe,UAAUC,SAAS,qBACzBC,EAAEC,gBAAgBC,UAAUnB,OAAOoB,IAAIC,UAExCrB,OAAOsB,QAAUf,IAJjBP,OAAOU,UAAYD,QAAQF,sCAMlBD,UAAWT,WAAYC,SAExCD,WAUX0B,IAAIvB,yJACIH,WAACA,WAADC,KAAaA,MAAQG,KAAKL,gBAEjB,IAAI4B,IAAI,iEACdvB,KAAKC,aAAaC,oBAAoBH,OAAOI,KAAM,gDAAnDqB,uBAA2DC,iEAAa,oEACxEzB,KAAKC,aAAaC,oBAAoBH,OAAOI,KAAM,+CAAnDuB,uBAA0DD,mEAAa,oEACvEzB,KAAKC,aAAaC,oBAAoBH,OAAOI,KAAM,kDAAnDwB,uBAA6DF,mEAAa,KAE5ErB,SAAQ,CAACC,UAAWC,OAEjBT,KADgB,UAAhBE,OAAOQ,KACAI,OAAOL,OAASK,OAAOX,KAAKY,iBAAiBb,SAC7B,WAAhBA,OAAOQ,MAAqBP,KAAKa,cAAcd,QAE/CA,OAAOU,UAAYD,QAAQF,KACX,aAAhBP,OAAOQ,MAAwBR,OAAOU,QAEtCV,OAAOe,UAAUC,SAAS,sBACxBC,EAAEC,gBAAgBC,UAAUnB,OAAOoB,IAAIC,UAEzCrB,OAAOsB,QAAUf,IAJjBP,OAAOU,UAAYD,QAAQF,sCAMlBD,UAAWT,WAAYC,SAExCD,WASXgC,GAAG7B,YACKH,WAACA,WAADC,KAAaA,MAAQG,KAAKL,qBACzBM,aAAaC,oBAAoBH,OAAOI,KAAM,MAAMC,SAAQ,CAACC,UAAWC,OACzET,KAAOS,IAAIuB,MAAM,KAAKC,SAAS/B,OAAOsB,wCAClBhB,UAAWT,WAAYC,SAExCD,WASXgB,iBAAiBb,cACU,UAAhBA,OAAOQ,KAAmBP,KAAKC,aAAa8B,KAAKC,SAASC,UAAUlC,OAAOI,MAAMkB,MAAQtB,OAAOsB,MAS3GR,cAAcd,eACoG,IAAvGC,KAAKC,aAAa8B,KAAKG,iBAAiB,8BAAgCnC,OAAOI,KAAO,MAAMgC,OAQvGC,YAAYL,iLACH9B,aAAe8B"}