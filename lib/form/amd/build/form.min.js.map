{"version":3,"file":"form.min.js","sources":["../src/form.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This file contains JS functionality required by mforms and is included automatically\n * when required.\n *\n * @see /lib/formslib.php#L2548 Candidate for removal, depends on grouped rules.\n * @see /lib/amd/src/showhidesettings.js Candidate for removal.\n *\n * @module     core_form/form\n * @copyright  2024 Mathew May <mathew.solutions>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\"use strict\";\n\nimport * as FormChangeChecker from './changechecker';\nimport * as Submit from './submit';\nimport Rules from './form/rules';\nimport * as MutateDom from './form/display';\nimport Pending from 'core/pending';\n\n// Namespace for the form bits and bobs\nM.form2 = M.form2 || new Map();\n\nexport default class Form {\n    /**\n     * @var {HTMLFormElement} form Our very own form to work on.\n     */\n    form;\n\n    /**\n     * @var {Map} dependencies Our map of form dependencies.\n     */\n    dependencies;\n\n    /**\n     * @var {Map} editors Our map of form editors used get the right selector.\n     */\n    editors = new Map();\n\n    /**\n     * @var {Array} initialDisabledHidden An array of elements that were hidden or disabled by default.\n     */\n    initialDisabledHidden = [];\n\n    /**\n     * Create a new form instance.\n     *\n     * @param {String} formID The ID of the form to be managed.\n     * @param {Object} dependencies The passed object of form dependencies.\n     */\n    constructor(formID, dependencies) {\n\n        // Set class properties.\n        this.form = document.querySelector(`#${formID}`);\n\n        const pendingPromise = new Pending('construction');\n        this.dependencies = this.getDependencyMapper(dependencies);\n        this.findSetEditors();\n        this.rules = new Rules(this);\n\n        // Apply the initial state of the form.\n        this.applyInitialState();\n\n        // Handle mutations within the form.\n        this.registerEventListeners();\n        FormChangeChecker.watchForm(this.form);\n        pendingPromise.resolve();\n    }\n\n    /**\n     * Given the page has loaded, apply the initial state of the form.\n     */\n    applyInitialState() {\n        [...this.form.elements].forEach((element) => {\n            if ((element.disabled || element.hidden) && element.name !== '') {\n                this.initialDisabledHidden.push(element.name);\n            }\n        });\n        const map = this.mapTemplate();\n        [...this.form.elements].forEach((element) => {\n            if (this.dependencies.has(element.name)) {\n                const testing = this.displayMapPrune(this.dispatchDependencyRules(element));\n                for (const [key, value] of testing) {\n                    map.get(key).push(...value);\n                }\n            }\n        });\n        const nMap = map.get('show').filter(x => {\n            return !map.get('hide').toString().includes(x.toString());\n        });\n        map.set('show', nMap);\n        const lMap = map.get('unlock').filter(x => {\n            return !map.get('lock').toString().includes(x.toString());\n        });\n        map.set('unlock', lMap);\n        this.domDispatch(map, true);\n    }\n\n    formUpdatedExternally() {\n        const map = this.mapTemplate();\n        [...this.form.elements].forEach((element) => {\n            if (this.dependencies.has(element.name)) {\n                const testing = this.displayMapPrune(this.dispatchDependencyRules(element));\n                for (const [key, value] of testing) {\n                    map.get(key).push(...value);\n                }\n            }\n        });\n        const nMap = map.get('show').filter(x => {\n            return !map.get('hide').toString().includes(x.toString());\n        });\n        map.set('show', nMap);\n        const lMap = map.get('unlock').filter(x => {\n            return !map.get('lock').toString().includes(x.toString());\n        });\n        map.set('unlock', lMap);\n        this.domDispatch(map);\n\n        if (map.get('show') !== undefined) {\n            const opened = this.elementNamesToDomNodes(map.get('show'));\n            const filterNullNodes = opened.filter((node) => node !== null);\n\n            filterNullNodes.forEach((node) => {\n                if (this.dependencies.has(node.name)) {\n                    const secondLvlResult = this.displayMapPrune(this.dispatchDependencyRules(node));\n                    this.domDispatch(secondLvlResult);\n                }\n            });\n        }\n    }\n    /**\n     * Add event listeners to the form.\n     */\n    registerEventListeners() {\n        // TODO: Choice dropdown does not trigger here.\n        this.form.addEventListener('change', async(e) => {\n            if (e.target.type === 'submit') {\n                FormChangeChecker.resetFormDirtyState(this.form);\n                Submit.init(e.target.id);\n            }\n            if (e.target.type === 'reset') {\n                FormChangeChecker.resetFormDirtyState(this.form);\n                this.form.reset();\n            }\n            // Something changes based on this element.\n            if (this.dependencies.has(e.target.name)) {\n                FormChangeChecker.markFormChangedFromNode(e.target);\n                const pendingPromise = new Pending('update');\n                const results = this.displayMapPrune(this.dispatchDependencyRules(e.target));\n                await this.domDispatch(results);\n\n                if (results.get('show') !== undefined) {\n                    const opened = this.elementNamesToDomNodes(results.get('show'));\n                    const filterNullNodes = opened.filter((node) => node !== null);\n\n                    filterNullNodes.forEach((node) => {\n                        if (this.dependencies.has(node.name)) {\n                            const secondLvlResult = this.displayMapPrune(this.dispatchDependencyRules(node));\n                            this.domDispatch(secondLvlResult);\n                        }\n                    });\n                }\n                pendingPromise.resolve();\n            }\n        });\n    }\n\n    /**\n     * Dispatch the dependency rules to the appropriate rule handler.\n     *\n     * @param {HTMLFormElement} target The name associated to the element that has changed.\n     * @returns {Map<String, Array>} Actions to be taken along with elements that should be affected.\n     */\n    dispatchDependencyRules(target) {\n        const displayMap = this.mapTemplate();\n        this.dependencies.get(target.name).forEach((dependants, ruleName) => {\n            // If the rule exists, use it, otherwise fallback to 'neq' which seems to be the \"default\" rule originally.\n            const elNamesMap = this.rules[ruleName] ? this.rules[ruleName](target) : this.rules.neq(target);\n            // Merge the current rule map with the final display map.\n            elNamesMap.forEach((nodeNames, displayOption) => {\n                // We want to merge in the new values into the existing value into a tight single array.\n                const spreadFlat = [...displayMap.get(displayOption), ...nodeNames.values()].flat();\n                displayMap.set(displayOption, spreadFlat);\n            });\n        });\n        return displayMap;\n    }\n\n    /**\n     * By default, the full display map contains empty entries and potential duplicated DOM node names.\n     * Here we will get rid of any empty entries and review the locked array. If a node name exists in both\n     * the locked and hidden array, it should be removed from the locked array as nodes are locked / disabled when hidden.\n     *\n     * @param {Map<String, Array>} displayMap Map of elements and their associated rules to prune.\n     * @returns {Map<String, Array>|Map<>} The pruned map or map even a fully pruned map if noting has to change.\n     */\n    displayMapPrune(displayMap) {\n        // Filter any unlocked items that pegged to be hidden as they must be locked if they are hidden.\n        const hideEvenIfUnlocked = displayMap.get('unlock').filter(x => {\n            return !displayMap.get('hide').toString().includes(x.toString());\n        });\n        displayMap.set('unlock', hideEvenIfUnlocked);\n\n        // Filter any shown items that pegged to be hidden.\n        const hideEvenIfShown = displayMap.get('show').filter(x => {\n            return !displayMap.get('hide').toString().includes(x.toString());\n        });\n        displayMap.set('show', hideEvenIfShown);\n\n        // Remove any empty entries.\n        for (const [key, value] of displayMap) {\n            if (value.length === 0) {\n                displayMap.delete(key);\n            }\n        }\n        return displayMap;\n    }\n\n    /**\n     * For a given element, get the names of DOM nodes that can change based on the given rule type name.\n     *\n     * @param {String} element The name of the element to get the dependants for.\n     * @param {String} type The rule type to get the dependants for.\n     * @returns {Array<String>|[]}\n     */\n    getDependantsOfType(element, type) {\n        return this.dependencies.get(element) !== 'undefined' ? this.dependencies.get(element).get(type) ?? [] : [];\n    }\n\n    /**\n     * Dispatch the DOM manipulation to the appropriate function.\n     *\n     * @param {Map<String, Array>} elNamesMap What needs to change.\n     * @param {Boolean} firstRun Whether this is the first run of the form.\n     */\n    domDispatch(elNamesMap = [], firstRun = false) {\n        window.console.log('Map', elNamesMap);\n        elNamesMap.forEach((elements, domUpdateOpt) => {\n            if (!MutateDom[domUpdateOpt]) {\n                return;\n            }\n            let nodes = [];\n            if (firstRun) {\n                // If something was hidden or disabled by default, we don't want to touch it.\n                const elCopy = elements.filter((el) => !this.initialDisabledHidden.includes(el));\n                nodes = this.elementNamesToDomNodes(elCopy);\n            } else {\n                nodes = this.elementNamesToDomNodes(elements);\n            }\n\n            nodes.forEach((node) => {\n                if (node === null) {\n                    return;\n                }\n                MutateDom[domUpdateOpt](node);\n            });\n        });\n    }\n\n    /**\n     * Convert the element names into DOM nodes based on the element names.\n     *\n     * @param {Array<String>} elementNames The name of dependent elements to get associated DOM nodes.\n     * @returns {Array<HTMLFormElement>}\n     */\n    elementNamesToDomNodes(elementNames) {\n        return elementNames.map((element) => {\n            if (this.form.querySelector(`[data-groupname=\"${element}\"]`)) {\n                return this.form.querySelector(`[data-groupname=\"${element}\"]`);\n            }\n            if (this.findSetEditors(element)) {\n                // Text editors are stupid.\n                return this.form.elements.namedItem(`${element}[text]`);\n            } else if (!this.form.elements.namedItem(element)) {\n                // Grouped items are stupid.\n                return this.form.elements.namedItem(`id_${element}`);\n            }\n            // Regular happy plain form item.\n            return this.form.elements.namedItem(element);\n        });\n    }\n\n    /**\n     * During init, look through the form and identify which elements are editors.\n     * Then when given an element name, we can check if it is an editor.\n     *\n     * @param {String} elementName A name of an element to check if it is an editor.\n     * @returns {Boolean} Whether the element is an editor or not.\n     */\n    findSetEditors(elementName = '') {\n        if (this.editors.size === 0) {\n            const fEditors = this.form.querySelectorAll('[data-fieldtype=\"editor\"] textarea');\n            Array.from(fEditors).forEach((node) => {\n                this.editors.set(node.name, true);\n            });\n        }\n        return this.editors.get(`${elementName}[text]`) || false;\n    }\n\n    /**\n     * Convert the dependencies object into a map of elements and their associated rules.\n     *\n     * @example\n     * Note: This is a simplified example of the returned map showing the rules for the grade type element in assign.\n     *\n     *      \"grade[modgrade_type]\" => Map {\n     *          \"eq\" => Map {\n     *              \"none\" => Object {\n     *                  1 => Array [\n     *                      \"advancedgradingmethod_submissions\",\n     *                      \"gradecat\",\n     *                      \"gradepass\",\n     *                      \"completionusegrade\",\n     *                      \"completionusegrade\",\n     *                  ]\n     *              }\n     *          },\n     *          \"neq\" => Map {\n     *              \"point\" => Object {\n     *                  1 => Array [\n     *                      \"grade[modgrade_point]\",\n     *                      \"grade[modgrade_rescalegrades]\"\n     *                  ]\n     *              },\n     *              \"scale\" => Object {\n     *                  1 => Array [\n     *                      \"grade[modgrade_scale]\"\n     *                  ]\n     *              }\n     *          }\n     *      }\n     *\n     * Note: If the value of grade[modgrade_type] === \"none\" then the array of elements defined should be hidden.\n     * Note: If the value of grade[modgrade_type] !== \"point\" then the array of elements defined within the following:\n     * \"eq\" => \"none\" && \"neq\" => \"scale\" should be hidden.\n     *\n     * Note: The object within the \"rule\" map can contain either 0 or 1 this helps determine if the element should be:\n     *       hidden or locked if the rule is met.\n     * @See /lib/formslib.php DEP_DISABLE & DEP_HIDE.\n     *\n     * @param {Object} dependencies The supplied object of form dependencies to migrate into a map.\n     * @returns {Map<String, Map>} A map of elements and their associated rules.\n     */\n    getDependencyMapper(dependencies) {\n        /**\n         * Convert the object into a first level map. i.e. elementName => ruleType.\n         *\n         * @type {Map<string, Map>} The map of rules associated to the given element.\n         * @example \"grade[modgrade_type]\" => Map<\"eq\", \"neq\">\n         */\n        const elementMap = new Map(Object.entries(dependencies));\n        elementMap.forEach((elementrules, key) => {\n            /**\n             * Convert the element rules object into a map.\n             *\n             * @type {Map<string, Map>} The map of rules associated to the given element.\n             * @example \"eq\" => Map<\"none\" => Object<Number, Array>>\n             * @example \"neq\" => Map<\"point\" => Object<Number, Array>, \"scale\" => Object<Number, Array>>\n             */\n            const ruleMap = new Map(Object.entries(elementrules));\n            ruleMap.forEach((ruleComparisons, key) => {\n                /**\n                 * Convert any disabledIf rules into objects, so we can manage them the same as hideIf items.\n                 *\n                 * @type {Map<string, Map>} The map of comparison values t.\n                 * @example \"none\" => \"none\" => Object<Number, Array>\n                 * @example \"neq\" => \"point\" => Object<Number, Array>\n                 */\n                const hideDefine = new Map(Object.entries(ruleComparisons));\n                hideDefine.forEach((action, compVal) => {\n                    if (Array.isArray(action)) {\n                        action = {...action};\n                    }\n                    hideDefine.set(compVal, action);\n                });\n                ruleMap.set(key, hideDefine);\n            });\n            elementMap.set(key, ruleMap);\n        });\n        return elementMap;\n    }\n\n    /**\n     * A standard map that we'll be using to figure out what has to change and how.\n     *\n     * @returns {Map<String, Array>}\n     */\n    mapTemplate() {\n        return new Map([\n            ['hide', []],\n            ['show', []],\n            ['lock', []],\n            ['unlock', []],\n        ]);\n    }\n\n    /**\n     * Initialize the form and its dependencies.\n     *\n     * @param {String} formID The ID of the form to be managed.\n     * @param {Object} dependencies The passed object of form dependencies.\n     * @returns {Form} An instance associated to a specific form on a given page.\n     */\n    static init(formID, dependencies) {\n        const instance = new Form(formID, dependencies);\n        // Add the Form instance to the global state so other modules can access this instance.\n        M.form2.set(formID, instance);\n        return instance;\n    }\n}\n"],"names":["M","form2","Map","Form","constructor","formID","dependencies","form","document","querySelector","pendingPromise","Pending","this","getDependencyMapper","findSetEditors","rules","Rules","applyInitialState","registerEventListeners","FormChangeChecker","watchForm","resolve","elements","forEach","element","disabled","hidden","name","initialDisabledHidden","push","map","mapTemplate","has","testing","displayMapPrune","dispatchDependencyRules","key","value","get","nMap","filter","x","toString","includes","set","lMap","domDispatch","formUpdatedExternally","undefined","elementNamesToDomNodes","node","secondLvlResult","addEventListener","async","e","target","type","resetFormDirtyState","Submit","init","id","reset","markFormChangedFromNode","results","displayMap","dependants","ruleName","neq","nodeNames","displayOption","spreadFlat","values","flat","hideEvenIfUnlocked","hideEvenIfShown","length","delete","getDependantsOfType","elNamesMap","firstRun","window","console","log","domUpdateOpt","MutateDom","nodes","elCopy","el","elementNames","namedItem","elementName","editors","size","fEditors","querySelectorAll","Array","from","elementMap","Object","entries","elementrules","ruleMap","ruleComparisons","hideDefine","action","compVal","isArray","instance"],"mappings":"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"}