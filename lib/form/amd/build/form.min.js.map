{"version":3,"file":"form.min.js","sources":["../src/form.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This file contains JS functionality required by mforms and is included automatically\n * when required.\n *\n * @see /lib/formslib.php#L2548 Candidate for removal, depends on grouped rules.\n * @see /lib/amd/src/showhidesettings.js Candidate for removal.\n *\n * @module     core_form/form\n * @copyright  2024 Mathew May <mathew.solutions>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n\"use strict\";\n\nimport * as FormChangeChecker from './changechecker';\nimport * as Submit from './submit';\nimport Rules from './form/rules';\nimport {mapTemplate} from './form/display';\nimport * as MutateDom from './form/display';\nimport Pending from 'core/pending';\n\nexport default class Form {\n    /**\n     * @var {Map<string, Form>} M.form2 Global map of forms currently on the page.\n     */\n    static #instances = new Map();\n\n    static getInstance(formID) {\n        return Form.#instances.get(formID);\n    }\n\n    static setInstance(formID, instance) {\n        Form.#instances.set(formID, instance);\n    }\n\n    /**\n     * @var {HTMLFormElement} form Our very own form to work on.\n     */\n    form;\n\n    /**\n     * @var {Map} dependencies Our map of form dependencies.\n     * @See this.getDependencyMapper() for structure info.\n     */\n    dependencies;\n\n    /**\n     * @var {Map<String, Boolean>} editors Our map of form editors used get the right selector.\n     */\n    editors;\n\n    /**\n     * @var {Map<String, Boolean>} staticElements Our map of static elements used get the right selector.\n     */\n    staticElements;\n\n    /**\n     * @var {Array<String>} initialDisabledHidden An array of element names that were hidden or disabled by default.\n     */\n    initialDisabledHidden = [];\n\n    /**\n     * Create a new Form instance.\n     *\n     * @param {String} formID The ID of the form to be managed.\n     * @param {Object} dependencies The passed object of form dependencies.\n     */\n    constructor(formID, dependencies) {\n        // Handle constructing the dependency map, finding editors and init the rules.\n        const pendingPromise = new Pending('construction');\n        this.form = document.querySelector(`#${formID}`);\n        this.dependencies = this.getDependencyMapper(dependencies);\n        this.editors = this.findEditors();\n        this.staticElements = this.findStaticElements();\n        this.rules = new Rules(this);\n\n        // Apply the initial state of the form.\n        this.applyInitialState();\n\n        // Handle mutations within the form.\n        this.registerEventListeners();\n        FormChangeChecker.watchForm(this.form);\n        pendingPromise.resolve();\n\n        Form.setInstance(formID, this);\n    }\n\n    /**\n     * On page load, apply the initial state of the form by checking the shown items and running their rules.\n     * We also want to confirm if anything has been hidden or disabled by a PHP callback on load and respect\n     * their wishes on page load.\n     */\n    applyInitialState() {\n        // Find any elements that are hidden or disabled by a PHP callback rule.\n        [...this.form.elements].forEach((element) => {\n            if ((element.disabled || element.hidden) && element.name !== '') {\n                this.initialDisabledHidden.push(element.name);\n            }\n        });\n        // Run through the form elements looking for anything to run rules against on load.\n        const map = this.generateDisplayMap();\n        this.domDispatch(map, true);\n    }\n\n    /**\n     * Somewhere out there, we have a form that wants to ensure the state of the form reflects their changes.\n     */\n    formUpdatedExternally() {\n        const map = this.generateDisplayMap();\n        this.domDispatch(map);\n\n        if (map.get('show') !== undefined) {\n            const opened = this.elementNamesToDomNodes(map.get('show'));\n            const filterNullNodes = opened.filter((node) => node !== null);\n\n            filterNullNodes.forEach((node) => {\n                if (this.dependencies.has(node.name)) {\n                    const secondLvlResult = this.displayMapPrune(this.dispatchDependencyRules(node));\n                    this.domDispatch(secondLvlResult);\n                }\n            });\n        }\n    }\n\n    /**\n     * Helper to iterate all the form elements that have a rule associated with them and generate a display map.\n     *\n     * @returns {Map<String, Array>}\n     */\n    generateDisplayMap() {\n        const map = mapTemplate();\n        [...this.form.elements].forEach((element) => {\n            if (this.dependencies.has(element.name)) {\n                const elDisplayMap = this.displayMapPrune(this.dispatchDependencyRules(element));\n                for (const [key, value] of elDisplayMap) {\n                    map.get(key).push(...value);\n                }\n            }\n        });\n        return map;\n    }\n\n    /**\n     * Add event listeners to the form.\n     */\n    registerEventListeners() {\n        // TODO: Choice dropdown does not trigger here.\n        this.form.addEventListener('change', async(e) => {\n            if (e.target.type === 'submit') {\n                FormChangeChecker.resetFormDirtyState(this.form);\n                Submit.init(e.target.id);\n            }\n            if (e.target.type === 'reset') {\n                FormChangeChecker.resetFormDirtyState(this.form);\n                this.form.reset();\n            }\n            // Something changes based on this element.\n            if (this.dependencies.has(e.target.name)) {\n                FormChangeChecker.markFormChangedFromNode(e.target);\n                const pendingPromise = new Pending('update');\n                const results = this.displayMapPrune(this.dispatchDependencyRules(e.target));\n                await this.domDispatch(results);\n\n                // Given that we are showing something,\n                // we'll do a second order check to see if we need to show more based on the new state of the form.\n                if (results.get('show') !== undefined) {\n                    const opened = this.elementNamesToDomNodes(results.get('show'));\n                    const filterNullNodes = opened.filter((node) => node !== null);\n\n                    filterNullNodes.forEach((node) => {\n                        const pendingPromise = new Pending('updatesecond');\n                        // RadioNodeList needs to be iterated through as it is not a simple element.\n                        if (node instanceof RadioNodeList) {\n                            node.forEach((n) => {\n                                if (this.dependencies.has(n.name)) {\n                                    const secondLvlResult = this.displayMapPrune(this.dispatchDependencyRules(n));\n                                    this.domDispatch(secondLvlResult);\n                                }\n                            });\n                        }\n                        if (this.dependencies.has(node.name)) {\n                            const secondLvlResult = this.displayMapPrune(this.dispatchDependencyRules(node));\n                            if (results.get('lock') !== undefined && secondLvlResult.get('unlock') !== undefined) {\n                                const keepLocked = secondLvlResult.get('unlock').filter(x => {\n                                    return results.get('lock').indexOf(x.toString()) === -1;\n                                });\n                                secondLvlResult.set('unlock', keepLocked);\n                                const removeShow = secondLvlResult.get('show').filter(x => {\n                                    return results.get('lock').indexOf(x.toString()) === -1;\n                                });\n                                secondLvlResult.set('show', removeShow);\n                            }\n                            this.domDispatch(secondLvlResult);\n                        }\n                        pendingPromise.resolve();\n                    });\n                }\n                pendingPromise.resolve();\n            }\n        });\n    }\n\n    /**\n     * Dispatch the dependency rules to the appropriate rule handler and get back a map of display options.\n     *\n     * @param {HTMLFormElement} target The name associated to the element that has changed.\n     * @returns {Map<String, Array<String>>} Actions to be taken along with element names that should be affected.\n     */\n    dispatchDependencyRules(target) {\n        const displayMap = mapTemplate();\n        this.dependencies.get(target.name).forEach((dependants, ruleName) => {\n            // If the rule exists, use it, otherwise fallback to 'neq' which seems to be the \"default\" rule originally.\n            const elNamesMap = this.rules[ruleName] ? this.rules[ruleName](target) : this.rules.neq(target);\n            // Merge the current rule map with the final display map.\n            elNamesMap.forEach((nodeNames, displayOption) => {\n                // We want to merge in the new array values into the existing array otherwise,\n                // we would get an array of arrays which is needless complexity.\n                displayMap.set(displayOption, [...displayMap.get(displayOption), ...nodeNames.values()].flat());\n            });\n        });\n        return displayMap;\n    }\n\n    /**\n     * By default, the full display map contains empty entries and potential duplicated DOM node names.\n     *\n     * First: We review the unlock array for node names that have to be hidden. If a match is found,\n     * the node name will be removed from being unlocked.\n     * Then: We review the show array for node names that have to be hidden. If a match is found,\n     * the node name will be removed from being shown as a rule has specified this should actually be hidden.\n     * Finally: We get rid of any empty entries within the display map to prevent running pointless display updates.\n     *\n     * @param {Map<String, Array>} displayMap Map of elements and their associated rules to prune.\n     * @returns {Map<String, Array>|Map<>} The pruned map or map even a fully pruned map if noting has to change.\n     */\n    displayMapPrune(displayMap) {\n        // Filter any unlocked items that pegged to be hidden as they must be locked if they are hidden.\n        // Using something like !displayMap.get('hide').toString().includes(x.toString()) did not work as\n        // it could result in false positives such as contentfoobar includes content when doing the eval.\n        if (displayMap.get('unlock') !== undefined) {\n            if (displayMap.get('hide') !== undefined) {\n                const hideEvenIfUnlocked = displayMap.get('unlock').filter(x => {\n                    return displayMap.get('hide').indexOf(x.toString()) === -1;\n                });\n                displayMap.set('unlock', hideEvenIfUnlocked);\n            }\n            if (displayMap.get('lock') !== undefined) {\n                const lockEvenIfUnlocked = displayMap.get('unlock').filter(x => {\n                    return displayMap.get('lock').indexOf(x.toString()) === -1;\n                });\n                displayMap.set('unlock', lockEvenIfUnlocked);\n            }\n        }\n\n        // Filter any shown items that pegged to be hidden.\n        if (displayMap.get('show') !== undefined && displayMap.get('hide') !== undefined) {\n            const hideEvenIfShown = displayMap.get('show').filter(x => {\n                return displayMap.get('hide').indexOf(x.toString()) === -1;\n            });\n            displayMap.set('show', hideEvenIfShown);\n        }\n\n        // Remove any empty entries.\n        for (const [key, value] of displayMap) {\n            if (value.length === 0) {\n                displayMap.delete(key);\n            }\n        }\n        return displayMap;\n    }\n\n    /**\n     * For a given element, get the names of DOM nodes that can change based on the given rule type name.\n     *\n     * @param {String} elementName The name of the element to get the dependants for.\n     * @param {String} ruleName The rule type to get the dependants for.\n     * @returns {Map<String, Array>|[]} Either the rule comparison value with associated node names to update or an empty array.\n     */\n    getDependantsOfType(elementName, ruleName) {\n        return this.dependencies.get(elementName) !== 'undefined' ? this.dependencies.get(elementName).get(ruleName) ?? [] : [];\n    }\n\n    /**\n     * Dispatch the DOM manipulation to the appropriate function.\n     *\n     * @param {Map<String, Array>} elNamesMap What needs to change.\n     * @param {Boolean|Null} firstRun Whether this is the first run of the form if so,\n     * filter some elements based on PHP rule callback values.\n     */\n    domDispatch(elNamesMap, firstRun = false) {\n        elNamesMap = this.displayMapPrune(elNamesMap);\n        // Go through the pruned display map and perform the requested display action.\n        elNamesMap.forEach((elements, domUpdateOpt) => {\n            // The requested display function somehow does not exist.\n            if (!MutateDom[domUpdateOpt]) {\n                return;\n            }\n            // If something was hidden or disabled by default via PHP rule callback, we don't want to touch it.\n            if (firstRun) {\n                elements = elements.filter((el) => !this.initialDisabledHidden.includes(el));\n            }\n\n            // Given the node names to update for a given display action, grab their associated HTMLFormElement and update them.\n            this.elementNamesToDomNodes(elements).forEach((node) => {\n                // Ensure we only update form items, instanceof check is a bit too much here as we have RadioNodeList items.\n                if (node === null) {\n                    return;\n                }\n                if (node instanceof RadioNodeList) {\n                    node.forEach((el) => {\n                        MutateDom[domUpdateOpt](el);\n                    });\n                } else if (node.hasAttribute('data-name')) {\n                    // Handle the parent to set stuff.\n                    MutateDom[domUpdateOpt](node.closest('.fitem'));\n                    // Look for form item stuff within the parent.\n                    const formItems = [...node.childNodes].filter((el) => {\n                        return ['INPUT', 'SELECT', 'TEXTAREA', 'BUTTON', 'A'].includes(el.tagName);\n                    });\n                    formItems.forEach((el) => {\n                        MutateDom[domUpdateOpt](el);\n                    });\n                } else {\n                    // Given a HTMLFormElement, perform the requested display action.\n                    MutateDom[domUpdateOpt](node);\n                }\n            });\n        });\n    }\n\n    /**\n     * Convert element names into DOM nodes based on the element name or a compound selector based on the given name.\n     *\n     * @param {Array<String>} elementNames The name of dependent elements to get associated DOM nodes.\n     * @returns {Array<HTMLFormElement|RadioNodeList>} DOM items to perform display actions on.\n     */\n    elementNamesToDomNodes(elementNames) {\n        return elementNames.map((element) => {\n            if (this.form.querySelector(`[data-groupname=\"${element}\"]`)) {\n                return this.form.querySelector(`[data-groupname=\"${element}\"]`);\n            } else if (this.staticElements.get(element)) {\n                // Static elements are stupid.\n                return this.form.querySelector(`[data-name=\"${element}\"]`);\n            } else if (this.editors.get(`${element}[text]`)) {\n                // Text editors are stupid.\n                return this.form.elements.namedItem(`${element}[text]`);\n            } else if (!this.form.elements.namedItem(element)) {\n                // Grouped items are stupid.\n                return this.form.elements.namedItem(`id_${element}`);\n            }\n            // Regular happy plain form item or RadioNodeList.\n            return this.form.elements.namedItem(element);\n        });\n    }\n\n    /**\n     * During init, look through the form and identify which elements are editors.\n     *\n     * @returns {Map<String, Boolean>} Map of found editors.\n     */\n    findEditors() {\n        let found = new Map();\n        const fEditors = this.form.querySelectorAll('[data-fieldtype=\"editor\"] textarea');\n        Array.from(fEditors).forEach((node) => {\n            found.set(node.name, true);\n        });\n        return found;\n    }\n\n    /**\n     * During init, look through the form and identify any static elements.\n     *\n     * @returns {Map<String, Boolean>} Map of found static elements.\n     */\n    findStaticElements() {\n        let found = new Map();\n        const fStatic = this.form.querySelectorAll('.fitem [data-fieldtype=\"static\"] .form-control-static');\n        Array.from(fStatic).forEach((node) => {\n            found.set(node.dataset.name, true);\n        });\n        return found;\n    }\n\n    /**\n     * Convert the dependencies object into a map of elements and their associated rules.\n     *\n     * @example\n     * Note: This is a simplified example of the returned map showing the rules for the grade type element in assign.\n     *\n     *      \"grade[modgrade_type]\" => Map {\n     *          \"eq\" => Map {\n     *              \"none\" => Object {\n     *                  1 => Array [\n     *                      \"advancedgradingmethod_submissions\",\n     *                      \"gradecat\",\n     *                      \"gradepass\",\n     *                      \"completionusegrade\",\n     *                      \"completionusegrade\",\n     *                  ]\n     *              }\n     *          },\n     *          \"neq\" => Map {\n     *              \"point\" => Object {\n     *                  1 => Array [\n     *                      \"grade[modgrade_point]\",\n     *                      \"grade[modgrade_rescalegrades]\"\n     *                  ]\n     *              },\n     *              \"scale\" => Object {\n     *                  1 => Array [\n     *                      \"grade[modgrade_scale]\"\n     *                  ]\n     *              }\n     *          }\n     *      }\n     *\n     * Note: If the value of grade[modgrade_type] === \"none\" then the array of elements defined should be hidden.\n     * Note: If the value of grade[modgrade_type] !== \"point\" then the array of elements defined within the following:\n     * \"eq\" => \"none\" && \"neq\" => \"scale\" should be hidden.\n     *\n     * Note: The object within the \"rule\" map can contain either 0 or 1 this helps determine if the element should be:\n     *       hidden or locked if the rule is met.\n     * @See /lib/formslib.php DEP_DISABLE & DEP_HIDE.\n     *\n     * @param {Object} dependencies The supplied object of form dependencies to migrate into a map.\n     * @returns {Map<String, Map>} A map of elements and their associated rules.\n     */\n    getDependencyMapper(dependencies) {\n        /**\n         * Convert the object into a first level map. i.e. elementName => ruleType.\n         *\n         * @type {Map<string, Map>} The map of rules associated to the given element.\n         * @example \"grade[modgrade_type]\" => Map<\"eq\", \"neq\">\n         */\n        const elementMap = new Map(Object.entries(dependencies));\n        elementMap.forEach((elementrules, key) => {\n            /**\n             * Convert the element rules object into a map.\n             *\n             * @type {Map<string, Map>} The map of rules associated to the given element.\n             * @example \"eq\" => Map<\"none\" => Object<Number, Array>>\n             * @example \"neq\" => Map<\"point\" => Object<Number, Array>, \"scale\" => Object<Number, Array>>\n             */\n            const ruleMap = new Map(Object.entries(elementrules));\n            ruleMap.forEach((ruleComparisons, key) => {\n                /**\n                 * Convert any disabledIf rules into objects, so we can manage them the same as hideIf items.\n                 *\n                 * @type {Map<string, Map>} The map of comparison values.\n                 * @example \"none\" => \"none\" => Object<Number, Array>\n                 * @example \"neq\" => \"point\" => Object<Number, Array>\n                 */\n                const hideDefine = new Map(Object.entries(ruleComparisons));\n                hideDefine.forEach((action, compVal) => {\n                    if (Array.isArray(action)) {\n                        action = {...action};\n                    }\n                    hideDefine.set(compVal, action);\n                });\n                ruleMap.set(key, hideDefine);\n            });\n            elementMap.set(key, ruleMap);\n        });\n        return elementMap;\n    }\n\n    /**\n     * Initialize the form and its dependencies. Also add the Form instance to the global state.\n     *\n     * @param {String} formID The ID of the form to be managed.\n     * @param {Object} dependencies The passed object of form dependencies.\n     * @returns {Form} An instance associated to a specific form on a given page.\n     */\n    static init(formID, dependencies) {\n        return new Form(formID, dependencies);\n    }\n}\n"],"names":["Form","formID","_classStaticPrivateFieldSpecGet","get","instance","set","constructor","dependencies","pendingPromise","Pending","form","document","querySelector","this","getDependencyMapper","editors","findEditors","staticElements","findStaticElements","rules","Rules","applyInitialState","registerEventListeners","FormChangeChecker","watchForm","resolve","setInstance","elements","forEach","element","disabled","hidden","name","initialDisabledHidden","push","map","generateDisplayMap","domDispatch","formUpdatedExternally","undefined","elementNamesToDomNodes","filter","node","has","secondLvlResult","displayMapPrune","dispatchDependencyRules","elDisplayMap","key","value","addEventListener","async","e","target","type","resetFormDirtyState","Submit","init","id","reset","markFormChangedFromNode","results","RadioNodeList","n","keepLocked","x","indexOf","toString","removeShow","displayMap","dependants","ruleName","neq","nodeNames","displayOption","values","flat","hideEvenIfUnlocked","lockEvenIfUnlocked","hideEvenIfShown","length","delete","getDependantsOfType","elementName","elNamesMap","firstRun","domUpdateOpt","MutateDom","el","includes","hasAttribute","closest","childNodes","tagName","elementNames","namedItem","found","Map","fEditors","querySelectorAll","Array","from","fStatic","dataset","elementMap","Object","entries","elementrules","ruleMap","ruleComparisons","hideDefine","action","compVal","isArray"],"mappings":"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"}